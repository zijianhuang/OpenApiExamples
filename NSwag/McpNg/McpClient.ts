//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export namespace MyNS {
export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class MyClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://test.healthclaiming.api.humanservices.gov.au/claiming/ext-vnd";
    }

    /**
     * This is the request
     * @param body (optional) 
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpBulkBillPaymentReport(body: any | undefined, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<BBSPaymentReportResponseType> {
        let url_ = this.baseUrl + "/mcp/bulkbillpaymentreport/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpBulkBillPaymentReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpBulkBillPaymentReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BBSPaymentReportResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BBSPaymentReportResponseType>;
        }));
    }

    protected processMcpBulkBillPaymentReport(response: HttpResponseBase): Observable<BBSPaymentReportResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BBSPaymentReportResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param body (optional) 
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpBulkBillProcessingReport(body: any | undefined, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<BBSProcessingReportResponseType> {
        let url_ = this.baseUrl + "/mcp/bulkbillprocessingreport/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpBulkBillProcessingReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpBulkBillProcessingReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BBSProcessingReportResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BBSProcessingReportResponseType>;
        }));
    }

    protected processMcpBulkBillProcessingReport(response: HttpResponseBase): Observable<BBSProcessingReportResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BBSProcessingReportResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param body (optional) 
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpBulkBillStoreForwardGeneral(body: any | undefined, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<BulkBillStoreForwardResponseType> {
        let url_ = this.baseUrl + "/mcp/bulkbillstoreforward/general/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpBulkBillStoreForwardGeneral(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpBulkBillStoreForwardGeneral(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BulkBillStoreForwardResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BulkBillStoreForwardResponseType>;
        }));
    }

    protected processMcpBulkBillStoreForwardGeneral(response: HttpResponseBase): Observable<BulkBillStoreForwardResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BulkBillStoreForwardResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param body (optional) 
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpBulkBillStoreForwardPathology(body: any | undefined, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<BulkBillStoreForwardResponseType> {
        let url_ = this.baseUrl + "/mcp/bulkbillstoreforward/pathology/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpBulkBillStoreForwardPathology(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpBulkBillStoreForwardPathology(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BulkBillStoreForwardResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BulkBillStoreForwardResponseType>;
        }));
    }

    protected processMcpBulkBillStoreForwardPathology(response: HttpResponseBase): Observable<BulkBillStoreForwardResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BulkBillStoreForwardResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param body (optional) 
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpBulkBillStoreForwardSpecialist(body: any | undefined, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<BulkBillStoreForwardResponseType> {
        let url_ = this.baseUrl + "/mcp/bulkbillstoreforward/specialist/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpBulkBillStoreForwardSpecialist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpBulkBillStoreForwardSpecialist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BulkBillStoreForwardResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BulkBillStoreForwardResponseType>;
        }));
    }

    protected processMcpBulkBillStoreForwardSpecialist(response: HttpResponseBase): Observable<BulkBillStoreForwardResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BulkBillStoreForwardResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param body (optional) 
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpDvaAlliedHealthAllied(body: any | undefined, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<AlliedHealthClaimResponseType> {
        let url_ = this.baseUrl + "/mcp/dvaalliedhealth/allied/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpDvaAlliedHealthAllied(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpDvaAlliedHealthAllied(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlliedHealthClaimResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlliedHealthClaimResponseType>;
        }));
    }

    protected processMcpDvaAlliedHealthAllied(response: HttpResponseBase): Observable<AlliedHealthClaimResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AlliedHealthClaimResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param body (optional) 
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpDvaAlliedHealthCommunityNursing(body: any | undefined, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<AlliedHealthClaimResponseType> {
        let url_ = this.baseUrl + "/mcp/dvaalliedhealth/communitynursing/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpDvaAlliedHealthCommunityNursing(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpDvaAlliedHealthCommunityNursing(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlliedHealthClaimResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlliedHealthClaimResponseType>;
        }));
    }

    protected processMcpDvaAlliedHealthCommunityNursing(response: HttpResponseBase): Observable<AlliedHealthClaimResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AlliedHealthClaimResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param body (optional) 
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpDvaAlliedHealthDental(body: any | undefined, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<AlliedHealthClaimResponseType> {
        let url_ = this.baseUrl + "/mcp/dvaalliedhealth/dental/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpDvaAlliedHealthDental(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpDvaAlliedHealthDental(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlliedHealthClaimResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlliedHealthClaimResponseType>;
        }));
    }

    protected processMcpDvaAlliedHealthDental(response: HttpResponseBase): Observable<AlliedHealthClaimResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AlliedHealthClaimResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param body (optional) 
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpDvaAlliedHealthOptical(body: any | undefined, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<AlliedHealthClaimResponseType> {
        let url_ = this.baseUrl + "/mcp/dvaalliedhealth/optical/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpDvaAlliedHealthOptical(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpDvaAlliedHealthOptical(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlliedHealthClaimResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlliedHealthClaimResponseType>;
        }));
    }

    protected processMcpDvaAlliedHealthOptical(response: HttpResponseBase): Observable<AlliedHealthClaimResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AlliedHealthClaimResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param body (optional) 
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpDvaAlliedHealthPsych(body: any | undefined, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<AlliedHealthClaimResponseType> {
        let url_ = this.baseUrl + "/mcp/dvaalliedhealth/psych/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpDvaAlliedHealthPsych(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpDvaAlliedHealthPsych(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlliedHealthClaimResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlliedHealthClaimResponseType>;
        }));
    }

    protected processMcpDvaAlliedHealthPsych(response: HttpResponseBase): Observable<AlliedHealthClaimResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AlliedHealthClaimResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param body (optional) 
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpDvaAlliedHealthSpeechPathology(body: any | undefined, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<AlliedHealthClaimResponseType> {
        let url_ = this.baseUrl + "/mcp/dvaalliedhealth/speechpathology/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpDvaAlliedHealthSpeechPathology(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpDvaAlliedHealthSpeechPathology(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlliedHealthClaimResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlliedHealthClaimResponseType>;
        }));
    }

    protected processMcpDvaAlliedHealthSpeechPathology(response: HttpResponseBase): Observable<AlliedHealthClaimResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AlliedHealthClaimResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param body (optional) 
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpDvaClaimGeneral(body: any | undefined, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<DVAClaimResponseType> {
        let url_ = this.baseUrl + "/mcp/dvaclaim/general/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpDvaClaimGeneral(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpDvaClaimGeneral(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DVAClaimResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DVAClaimResponseType>;
        }));
    }

    protected processMcpDvaClaimGeneral(response: HttpResponseBase): Observable<DVAClaimResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DVAClaimResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param body (optional) 
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpDvaClaimPathology(body: any | undefined, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<DVAClaimResponseType> {
        let url_ = this.baseUrl + "/mcp/dvaclaim/pathology/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpDvaClaimPathology(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpDvaClaimPathology(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DVAClaimResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DVAClaimResponseType>;
        }));
    }

    protected processMcpDvaClaimPathology(response: HttpResponseBase): Observable<DVAClaimResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DVAClaimResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param body (optional) 
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpDvaClaimSpecialist(body: any | undefined, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<DVAClaimResponseType> {
        let url_ = this.baseUrl + "/mcp/dvaclaim/specialist/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpDvaClaimSpecialist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpDvaClaimSpecialist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DVAClaimResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DVAClaimResponseType>;
        }));
    }

    protected processMcpDvaClaimSpecialist(response: HttpResponseBase): Observable<DVAClaimResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DVAClaimResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param body (optional) 
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpDvaPaymentReport(body: any | undefined, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<DVAPaymentReportResponseType> {
        let url_ = this.baseUrl + "/mcp/dvapaymentreport/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpDvaPaymentReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpDvaPaymentReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DVAPaymentReportResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DVAPaymentReportResponseType>;
        }));
    }

    protected processMcpDvaPaymentReport(response: HttpResponseBase): Observable<DVAPaymentReportResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DVAPaymentReportResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param body (optional) 
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpDvaProcessingReport(body: any | undefined, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<DVAProcessingReportResponseType> {
        let url_ = this.baseUrl + "/mcp/dvaprocessingreport/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpDvaProcessingReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpDvaProcessingReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DVAProcessingReportResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DVAProcessingReportResponseType>;
        }));
    }

    protected processMcpDvaProcessingReport(response: HttpResponseBase): Observable<DVAProcessingReportResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DVAProcessingReportResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpEnterpriseConcessionVerification(body: EnterpriseConcessionVerificationRequestType, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<EnterpriseConcessionVerificationResponseType> {
        let url_ = this.baseUrl + "/mcp/enterpriseconcessionverification/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpEnterpriseConcessionVerification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpEnterpriseConcessionVerification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnterpriseConcessionVerificationResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnterpriseConcessionVerificationResponseType>;
        }));
    }

    protected processMcpEnterpriseConcessionVerification(response: HttpResponseBase): Observable<EnterpriseConcessionVerificationResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EnterpriseConcessionVerificationResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpEnterprisePatientVerification(body: EnterprisePatientVerificationRequestType, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<EnterprisePatientVerificationResponseType> {
        let url_ = this.baseUrl + "/mcp/enterprisepatientverification/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpEnterprisePatientVerification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpEnterprisePatientVerification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnterprisePatientVerificationResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnterprisePatientVerificationResponseType>;
        }));
    }

    protected processMcpEnterprisePatientVerification(response: HttpResponseBase): Observable<EnterprisePatientVerificationResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EnterprisePatientVerificationResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpEnterpriseVeteranVerification(body: EnterpriseVeteranVerificationRequestType, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<EnterpriseVeteranVerificationResponseType> {
        let url_ = this.baseUrl + "/mcp/enterpriseveteranverification/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpEnterpriseVeteranVerification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpEnterpriseVeteranVerification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnterpriseVeteranVerificationResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnterpriseVeteranVerificationResponseType>;
        }));
    }

    protected processMcpEnterpriseVeteranVerification(response: HttpResponseBase): Observable<EnterpriseVeteranVerificationResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EnterpriseVeteranVerificationResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param body (optional) 
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpPatientClaimInteractiveGeneral(body: any | undefined, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<PatientClaimInteractiveResponseType> {
        let url_ = this.baseUrl + "/mcp/patientclaiminteractive/general/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpPatientClaimInteractiveGeneral(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpPatientClaimInteractiveGeneral(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PatientClaimInteractiveResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PatientClaimInteractiveResponseType>;
        }));
    }

    protected processMcpPatientClaimInteractiveGeneral(response: HttpResponseBase): Observable<PatientClaimInteractiveResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PatientClaimInteractiveResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param body (optional) 
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpPatientClaimInteractivePathology(body: any | undefined, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<PatientClaimInteractiveResponseType> {
        let url_ = this.baseUrl + "/mcp/patientclaiminteractive/pathology/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpPatientClaimInteractivePathology(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpPatientClaimInteractivePathology(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PatientClaimInteractiveResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PatientClaimInteractiveResponseType>;
        }));
    }

    protected processMcpPatientClaimInteractivePathology(response: HttpResponseBase): Observable<PatientClaimInteractiveResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PatientClaimInteractiveResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param body (optional) 
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpPatientClaimInteractiveSpecialist(body: any | undefined, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<PatientClaimInteractiveResponseType> {
        let url_ = this.baseUrl + "/mcp/patientclaiminteractive/specialist/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpPatientClaimInteractiveSpecialist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpPatientClaimInteractiveSpecialist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PatientClaimInteractiveResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PatientClaimInteractiveResponseType>;
        }));
    }

    protected processMcpPatientClaimInteractiveSpecialist(response: HttpResponseBase): Observable<PatientClaimInteractiveResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PatientClaimInteractiveResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param body (optional) 
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpPatientVerification(body: any | undefined, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<PatientVerificationResponseType> {
        let url_ = this.baseUrl + "/mcp/patientverification/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpPatientVerification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpPatientVerification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PatientVerificationResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PatientVerificationResponseType>;
        }));
    }

    protected processMcpPatientVerification(response: HttpResponseBase): Observable<PatientVerificationResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PatientVerificationResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param body (optional) 
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpPatientVerificationHf(body: any | undefined, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<PatientVerificationResponseType> {
        let url_ = this.baseUrl + "/mcp/patientverification/hf/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpPatientVerificationHf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpPatientVerificationHf(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PatientVerificationResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PatientVerificationResponseType>;
        }));
    }

    protected processMcpPatientVerificationHf(response: HttpResponseBase): Observable<PatientVerificationResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PatientVerificationResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param body (optional) 
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpPatientVerificationMedicare(body: any | undefined, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<PatientVerificationResponseType> {
        let url_ = this.baseUrl + "/mcp/patientverification/medicare/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpPatientVerificationMedicare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpPatientVerificationMedicare(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PatientVerificationResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PatientVerificationResponseType>;
        }));
    }

    protected processMcpPatientVerificationMedicare(response: HttpResponseBase): Observable<PatientVerificationResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PatientVerificationResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param body (optional) 
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpRetrieveReportEcv(body: any | undefined, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<RetrieveReportResponseType> {
        let url_ = this.baseUrl + "/mcp/enterpriseconcessionverification/retrievereport/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpRetrieveReportEcv(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpRetrieveReportEcv(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetrieveReportResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetrieveReportResponseType>;
        }));
    }

    protected processMcpRetrieveReportEcv(response: HttpResponseBase): Observable<RetrieveReportResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RetrieveReportResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param body (optional) 
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpRetrieveReportEpv(body: any | undefined, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<RetrieveReportResponseType> {
        let url_ = this.baseUrl + "/mcp/enterprisepatientverification/retrievereport/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpRetrieveReportEpv(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpRetrieveReportEpv(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetrieveReportResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetrieveReportResponseType>;
        }));
    }

    protected processMcpRetrieveReportEpv(response: HttpResponseBase): Observable<RetrieveReportResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RetrieveReportResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param body (optional) 
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpRetrieveReportEvv(body: any | undefined, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<RetrieveReportResponseType> {
        let url_ = this.baseUrl + "/mcp/enterpriseveteranverification/retrievereport/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpRetrieveReportEvv(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpRetrieveReportEvv(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetrieveReportResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetrieveReportResponseType>;
        }));
    }

    protected processMcpRetrieveReportEvv(response: HttpResponseBase): Observable<RetrieveReportResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RetrieveReportResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpSameDayDelete(body: SameDayDeleteRequestType, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<SameDayDeleteResponseType> {
        let url_ = this.baseUrl + "/mcp/samedaydelete/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpSameDayDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpSameDayDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SameDayDeleteResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SameDayDeleteResponseType>;
        }));
    }

    protected processMcpSameDayDelete(response: HttpResponseBase): Observable<SameDayDeleteResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SameDayDeleteResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpStatusReport(body: StatusReportRequestType, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<StatusReportResponseType> {
        let url_ = this.baseUrl + "/mcp/statusreport/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpStatusReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpStatusReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusReportResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusReportResponseType>;
        }));
    }

    protected processMcpStatusReport(response: HttpResponseBase): Observable<StatusReportResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusReportResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpVeteranVerification(body: VeteranVerificationRequestType, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<VeteranVerificationResponseType> {
        let url_ = this.baseUrl + "/mcp/veteranverification/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpVeteranVerification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpVeteranVerification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VeteranVerificationResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VeteranVerificationResponseType>;
        }));
    }

    protected processMcpVeteranVerification(response: HttpResponseBase): Observable<VeteranVerificationResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as VeteranVerificationResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface BBSReportRequestType {
    payeeProvider: ProviderType;
    claimId?: string;
    lodgementDate?: Date;
}

export interface ProviderType {
    providerNumber: string;
}

export interface BBSPaymentReportResponseType {
    paymentRun?: PaymentRunType;
    paymentInfo?: PaymentType;
    claimSummary?: ClaimSummaryType[];
    status: string;
}

export interface PaymentRunType {
    payerName?: string;
    runDate?: Date;
    runNumber?: string;
}

export interface PaymentType {
    accountInfo: BankAccountType;
    depositAmount?: string;
    paymentReference?: string;
}

export interface BankAccountType {
    accountName?: string;
    accountNumber?: string;
    bsbCode?: string;
}

export interface ClaimSummaryType {
    accountReferenceId?: string;
    benefit?: string;
    chargeAmount?: string;
    claimChannelCode?: string;
    claimId?: string;
    lodgementDate?: Date;
    transactionId?: string;
}

export interface ServiceMessagesType {
    highestSeverity: ServiceMessagesTypeHighestSeverity;
    serviceMessage: ServiceMessageType[];
}

export interface ServiceMessageType {
    code: string;
    severity: ServiceMessageTypeSeverity;
    reason: string;
}

export interface BBSProcessingReportResponseType {
    claimAssessment?: ClaimAssessmentType;
    status: string;
}

export interface ClaimAssessmentType {
    medicalEvent?: MedicalEventResponseType[];
    serviceProvider?: ProviderType;
    benefitPaid?: string;
    chargeAmount?: string;
    claimId?: string;
}

export interface MedicalEventResponseType {
    patient?: MembershipStatusType;
    service?: ServiceResponseType[];
    id?: string;
    eventDate?: Date;
}

export interface MembershipStatusType {
    status?: StatusType;
    currentMembership?: MembershipType;
    currentMember?: IdentityType;
    processDate?: Date;
}

export interface StatusType {
    code?: number;
    text?: string;
}

export interface MembershipType {
    memberNumber?: string;
    memberRefNumber?: string;
}

export interface IdentityType {
    dateOfBirth?: Date;
    familyName?: string;
    givenName?: string;
    secondInitial?: string;
    sex?: string;
}

export interface ServiceResponseType {
    error?: StatusType;
    id?: string;
    assessmentCode?: string;
    benefitPaid?: string;
    chargeAmount?: string;
    itemNumber?: string;
    numberOfPatientsSeen?: string;
}

export interface BulkBillStoreForwardRequestType {
    claim: BulkBillClaimStoreForwardClaimType;
}

export interface BulkBillClaimStoreForwardClaimType {
    facilityId?: string;
    hospitalInd?: string;
    medicalEvent: BBSMedicalEventType[];
    payeeProvider?: ProviderType;
    serviceProvider: ProviderType;
    serviceTypeCode: string;
}

export interface BBSMedicalEventType {
    id: string;
    authorisationDate: Date;
    createDateTime: Date;
    medicalEventDate: Date;
    medicalEventTime?: string;
    patient: MedicarePatientType;
    referral?: ReferralType;
    referralOverrideCode?: string;
    service: ServiceType[];
    submissionAuthorityInd: string;
}

export interface MedicarePatientType {
    identity: IdentityType;
    medicare: MembershipType;
}

export interface ReferralType {
    issueDate: Date;
    period?: string;
    periodCode?: string;
    provider: ProviderType;
    typeCode: string;
}

export interface ServiceType {
    id: string;
    accessionDateTime?: Date;
    aftercareOverrideInd?: string;
    chargeAmount?: string;
    collectionDateTime?: Date;
    duplicateServiceOverrideInd?: string;
    fieldQuantity?: string;
    itemNumber?: string;
    lspNumber?: string;
    multipleProcedureOverrideInd?: string;
    numberOfPatientsSeen?: string;
    restrictiveOverrideCode?: string;
    rule3ExemptInd?: string;
    s4b3ExemptInd?: string;
    scpId?: string;
    selfDeemedCode?: string;
    text?: string;
    timeDuration?: string;
}

export interface BulkBillStoreForwardResponseType {
    claimId: string;
    status: string;
}

export interface AlliedHealthClaimRequestType {
    claim: VAAClaimType;
}

export interface VAAClaimType {
    hospitalInd?: string;
    medicalEvent: VAAMedicalEventType[];
    payeeProvider?: ProviderType;
    serviceProvider: ProviderType;
    serviceTypeCode: string;
}

export interface VAAMedicalEventType {
    id: string;
    acceptedDisability?: AcceptedDisabilityType;
    authorisationDate: Date;
    breakInEpisodeEndDate?: Date;
    breakInEpisodeOfCareNumber?: string;
    breakInEpisodeStartDate?: Date;
    numberOfCNCHours?: string;
    numberOfCNCVisits?: string;
    createDateTime: Date;
    numberOfENHours?: string;
    numberOfENVisits?: string;
    facilityId?: string;
    medicalEventDate: Date;
    medicalEventTime?: string;
    numberOfNSSHours?: string;
    numberOfNSSVisits?: string;
    patient: VeteranPatientType;
    referral?: ReferralType;
    referralOverrideCode?: string;
    numberOfRNHours?: string;
    numberOfRNVisits?: string;
    service: VAAServiceType[];
    submissionAuthorityInd: string;
}

export interface AcceptedDisabilityType {
    code: string;
    ind: string;
}

export interface PatientType {
    identity: IdentityType;
    residentialAddress?: AddressType;
}

export interface VeteranPatientType extends PatientType {
    veteranMembership?: VeteranMembershipType;
}

export interface AddressType {
    addressLineOne?: string;
    addressLineTwo?: string;
    locality?: string;
    postcode?: string;
}

export interface VeteranMembershipType {
    veteranNumber: string;
}

export interface VAAServiceType {
    id: string;
    accountReferenceNumber?: string;
    admissionDate?: Date;
    chargeAmount?: string;
    dischargeDate?: Date;
    distanceKilometres?: number;
    duplicateServiceOverrideInd?: string;
    itemNumber: string;
    multipleProcedureOverrideInd?: string;
    numberOfPatientsSeen?: string;
    numberOfTeeth?: string;
    opticalScriptCode?: string;
    restrictiveOverrideCode?: string;
    secondDeviceInd?: string;
    selfDeemedCode?: string;
    text?: string;
    timeDuration?: string;
    toothNumber?: string;
    upperLowerJawCode?: string;
}

export interface AlliedHealthClaimResponseType {
    claimId: string;
    status: string;
}

export interface DVAClaimRequestType {
    claim: DVAClaimType;
}

export interface DVAClaimType {
    hospitalInd?: string;
    serviceTypeCode: string;
    medicalEvent: DVAMedicalEventType[];
    serviceProvider: ProviderType;
    payeeProvider?: ProviderType;
}

export interface DVAMedicalEventType {
    id: string;
    authorisationDate: Date;
    createDateTime: Date;
    facilityId?: string;
    medicalEventDate: Date;
    medicalEventTime?: string;
    referralOverrideCode?: string;
    submissionAuthorityInd: string;
    treatmentLocationCode?: string;
    acceptedDisability?: AcceptedDisabilityType;
    referral?: ReferralType;
    patient: VeteranPatientType;
    service: DVAServiceType[];
}

export interface DVAServiceType extends ServiceType {
    accountReferenceNumber?: string;
    distanceKilometres?: number;
}

export interface DVAClaimResponseType {
    claimId: string;
    status: string;
}

export interface DVAReportRequestType {
    payeeProvider: ProviderType;
    claimId?: string;
    lodgementDate?: Date;
}

export interface DVAPaymentReportResponseType {
    paymentRun?: PaymentRunType;
    paymentInfo?: PaymentType;
    claimSummary?: ClaimSummaryType[];
    status: string;
}

export interface DVAProcessingReportResponseType {
    claimAssessment?: DVAClaimAssessmentType;
    status: string;
}

export interface DVAClaimAssessmentType {
    medicalEvent?: DVAMedicalEventAssessmentType[];
    serviceProvider?: ProviderType;
    benefitPaid?: string;
    chargeAmount?: string;
    claimId?: string;
}

export interface DVAMedicalEventAssessmentType {
    patient?: VeteranMembershipStatusType;
    service?: DVAServiceAssessmentType[];
    id?: string;
    eventDate?: Date;
}

export interface VeteranMembershipStatusType {
    currentMembership?: VeteranMembershipResponseType;
    currentMember?: IdentityType;
    status?: StatusType;
    processDate?: Date;
}

export interface VeteranMembershipResponseType extends VeteranMembershipType {
    entitlementCode?: string;
}

export interface DVAServiceAssessmentType {
    id?: string;
    accountReferenceNumber?: string;
    assessmentCode?: string;
    benefitPaid?: string;
    chargeAmount?: string;
    gstInd?: string;
    itemNumber?: string;
    numberOfPatientsSeen?: string;
}

export interface EnterpriseConcessionVerificationRequestType {
    timeout?: number;
    concessionVerificationRequest: ReferenceConcessionVerificationRequestType[];
}

export interface ConcessionVerificationRequestType {
    patient: MedicarePatientType;
    dateOfService?: Date;
}

export interface ReferenceConcessionVerificationRequestType extends ConcessionVerificationRequestType {
    id: string;
}

export interface EnterpriseConcessionVerificationResponseType {
    status: string;
    concessionVerificationResponse?: ReferenceConcessionVerificationResponseType[];
}

export interface ConcessionVerificationResponseType {
    medicareStatus: MembershipStatusType;
    concessionStatus: ConcessionStatusType;
}

export interface ReferenceConcessionVerificationResponseType extends ConcessionVerificationResponseType {
    id: string;
}

export interface ConcessionStatusType {
    status?: StatusType;
    processDate?: Date;
}

export interface EnterprisePatientVerificationRequestType {
    timeout?: number;
    patientVerificationRequest: ReferencePatientVerificationRequestType[];
}

export interface PatientVerificationRequestType {
    patient: FundPatientType;
    provider?: ProviderType;
    dateOfService?: Date;
    typeCode: string;
}

export interface ReferencePatientVerificationRequestType extends PatientVerificationRequestType {
    id: string;
}

export interface FundPatientType extends PatientType {
    alsoKnownAs?: IdentityType;
    medicare?: MembershipType;
    healthFund?: FundMembershipType;
}

export interface FundMembershipType {
    memberNumber?: string;
    memberRefNumber?: string;
    organisation?: string;
}

export interface EnterprisePatientVerificationResponseType {
    status: string;
    patientVerificationResponse?: ReferencePatientVerificationResponseType[];
}

export interface PatientVerificationResponseType {
    medicareStatus?: MembershipStatusType;
    healthFundStatus?: FundMembershipStatusType;
}

export interface ReferencePatientVerificationResponseType extends PatientVerificationResponseType {
    id: string;
}

export interface FundMembershipStatusType {
    status?: StatusType;
    currentMembership?: FundMembershipType;
    currentMember?: IdentityType;
    processDate?: Date;
}

export interface EnterpriseVeteranVerificationRequestType {
    timeout?: number;
    veteranVerificationRequest: ReferenceVeteranVerificationRequestType[];
}

export interface VeteranVerificationRequestType {
    patient: VeteranPatientType;
}

export interface ReferenceVeteranVerificationRequestType extends VeteranVerificationRequestType {
    id: string;
}

export interface EnterpriseVeteranVerificationResponseType {
    status: string;
    veteranVerificationResponse?: ReferenceVeteranVerificationResponseType[];
}

export interface VeteranVerificationResponseType {
    veteranStatus?: VeteranMembershipStatusType;
}

export interface ReferenceVeteranVerificationResponseType extends VeteranVerificationResponseType {
    id?: string;
}

export interface PatientClaimInteractiveRequestType {
    patientClaimInteractive: PatientClaimInteractiveType;
}

export interface PatientClaimInteractiveType {
    patient: MedicarePatientType;
    referral?: ReferralType;
    claimant: ClaimantType;
    medicalEvent: PCIMedicalEventType[];
    payeeProvider?: ProviderType;
    serviceProvider: ProviderType;
    referralOverrideCode?: string;
    accountPaidInd: string;
    accountReferenceId?: string;
    submissionAuthorityInd: string;
    authorisationDate: Date;
}

export interface ClaimantType extends MedicarePatientType {
    eftDetails?: BankAccountType;
    residentialAddress?: AddressType;
    contactDetails?: ContactType;
}

export interface ContactType {
    emailAddress?: string;
    name?: string;
    phoneNumber?: string;
}

export interface PCIMedicalEventType {
    service: PCIServiceType[];
    id: string;
    medicalEventDate: Date;
    medicalEventTime?: string;
}

export interface PCIServiceType extends ServiceType {
    patientContribAmount?: string;
    facilityId?: string;
    hospitalInd?: string;
}

export interface PatientClaimInteractiveResponseType {
    claimAssessment: PCIAssessmentType;
    status: string;
}

export interface PCIAssessmentType {
    claimant?: CurrentMembershipType;
    patient?: CurrentMembershipType;
    medicalEvent?: PCIMedicalEventResponseType[];
    error?: StatusType;
    claimId: string;
}

export interface CurrentMembershipType {
    currentMembership: MembershipType;
}

export interface PCIMedicalEventResponseType {
    service?: ServiceResponseType[];
    eventDate?: Date;
    id?: string;
}

export interface RetrieveReportRequestType {
    transactionId: string[];
}

export interface RetrieveReportResponseType {
    content?: ContentType[];
}

export interface ContentType {
    transactionId?: string;
    status?: string;
}

export interface EnterpriseConcessionVerificationReportContentType extends ContentType {
    report?: EnterpriseConcessionVerificationResponseType;
}

export interface EnterprisePatientVerificationReportContentType extends ContentType {
    report?: EnterprisePatientVerificationResponseType;
}

export interface EnterpriseVeteranVerificationReportContentType extends ContentType {
    report?: EnterpriseVeteranVerificationResponseType;
}

export interface SameDayDeleteRequestType {
    sameDayDelete: SameDayDeleteType;
}

export interface SameDayDeleteType {
    patient: MedicarePatientType;
    reasonCode: string;
}

export interface SameDayDeleteResponseType {
    status: string;
}

export interface StatusReportRequestType {
    transactionId?: string[];
    associateName?: string;
    fromDateTime?: Date;
    toDateTime?: Date;
    reportStatus?: string;
    requestTransmissionType?: string;
    status?: string;
}

export interface StatusReportResponseType {
    transactionStatus?: TransactionStatusType[];
    status: string;
}

export interface TransactionStatusType {
    associateName?: string;
    lodgementDateTime?: Date;
    processStatus?: string;
    reference?: string;
    reportStatus?: string;
    requestTransmissionType?: string;
    transactionId?: string;
}

export enum ServiceMessagesTypeHighestSeverity {
    Fatal = "Fatal",
    Error = "Error",
    Warning = "Warning",
    Informational = "Informational",
}

export enum ServiceMessageTypeSeverity {
    Fatal = "Fatal",
    Error = "Error",
    Warning = "Warning",
    Informational = "Informational",
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}

}