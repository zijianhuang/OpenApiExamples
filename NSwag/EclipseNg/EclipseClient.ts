//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export namespace MyNS {
export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class MyClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://test.healthclaiming.api.humanservices.gov.au/claiming/ext-vnd";
    }

    /**
     * This is the request
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpGetParticipants(body: GetParticipantsRequestType, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<GetParticipantsResponseType> {
        let url_ = this.baseUrl + "/mcp/getparticipants/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpGetParticipants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpGetParticipants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetParticipantsResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetParticipantsResponseType>;
        }));
    }

    protected processMcpGetParticipants(response: HttpResponseBase): Observable<GetParticipantsResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetParticipantsResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpInPatientMedicalClaimAgGeneral(body: InPatientMedicalClaimRequestType, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<InPatientMedicalClaimResponseType> {
        let url_ = this.baseUrl + "/mcp/inpatientmedicalclaim/ag/general/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpInPatientMedicalClaimAgGeneral(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpInPatientMedicalClaimAgGeneral(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InPatientMedicalClaimResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InPatientMedicalClaimResponseType>;
        }));
    }

    protected processMcpInPatientMedicalClaimAgGeneral(response: HttpResponseBase): Observable<InPatientMedicalClaimResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InPatientMedicalClaimResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpInPatientMedicalClaimAgPathology(body: InPatientMedicalClaimRequestType, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<InPatientMedicalClaimResponseType> {
        let url_ = this.baseUrl + "/mcp/inpatientmedicalclaim/ag/pathology/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpInPatientMedicalClaimAgPathology(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpInPatientMedicalClaimAgPathology(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InPatientMedicalClaimResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InPatientMedicalClaimResponseType>;
        }));
    }

    protected processMcpInPatientMedicalClaimAgPathology(response: HttpResponseBase): Observable<InPatientMedicalClaimResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InPatientMedicalClaimResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpInPatientMedicalClaimAgSpecialist(body: InPatientMedicalClaimRequestType, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<InPatientMedicalClaimResponseType> {
        let url_ = this.baseUrl + "/mcp/inpatientmedicalclaim/ag/specialist/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpInPatientMedicalClaimAgSpecialist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpInPatientMedicalClaimAgSpecialist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InPatientMedicalClaimResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InPatientMedicalClaimResponseType>;
        }));
    }

    protected processMcpInPatientMedicalClaimAgSpecialist(response: HttpResponseBase): Observable<InPatientMedicalClaimResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InPatientMedicalClaimResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpInPatientMedicalClaimMbGeneral(body: InPatientMedicalClaimRequestType, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<InPatientMedicalClaimResponseType> {
        let url_ = this.baseUrl + "/mcp/inpatientmedicalclaim/mb/general/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpInPatientMedicalClaimMbGeneral(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpInPatientMedicalClaimMbGeneral(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InPatientMedicalClaimResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InPatientMedicalClaimResponseType>;
        }));
    }

    protected processMcpInPatientMedicalClaimMbGeneral(response: HttpResponseBase): Observable<InPatientMedicalClaimResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InPatientMedicalClaimResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpInPatientMedicalClaimMbPathology(body: InPatientMedicalClaimRequestType, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<InPatientMedicalClaimResponseType> {
        let url_ = this.baseUrl + "/mcp/inpatientmedicalclaim/mb/pathology/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpInPatientMedicalClaimMbPathology(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpInPatientMedicalClaimMbPathology(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InPatientMedicalClaimResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InPatientMedicalClaimResponseType>;
        }));
    }

    protected processMcpInPatientMedicalClaimMbPathology(response: HttpResponseBase): Observable<InPatientMedicalClaimResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InPatientMedicalClaimResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpInPatientMedicalClaimMbSpecialist(body: InPatientMedicalClaimRequestType, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<InPatientMedicalClaimResponseType> {
        let url_ = this.baseUrl + "/mcp/inpatientmedicalclaim/mb/specialist/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpInPatientMedicalClaimMbSpecialist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpInPatientMedicalClaimMbSpecialist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InPatientMedicalClaimResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InPatientMedicalClaimResponseType>;
        }));
    }

    protected processMcpInPatientMedicalClaimMbSpecialist(response: HttpResponseBase): Observable<InPatientMedicalClaimResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InPatientMedicalClaimResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpInPatientMedicalClaimMoGeneral(body: InPatientMedicalClaimRequestType, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<InPatientMedicalClaimResponseType> {
        let url_ = this.baseUrl + "/mcp/inpatientmedicalclaim/mo/general/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpInPatientMedicalClaimMoGeneral(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpInPatientMedicalClaimMoGeneral(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InPatientMedicalClaimResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InPatientMedicalClaimResponseType>;
        }));
    }

    protected processMcpInPatientMedicalClaimMoGeneral(response: HttpResponseBase): Observable<InPatientMedicalClaimResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InPatientMedicalClaimResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpInPatientMedicalClaimMoPathology(body: InPatientMedicalClaimRequestType, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<InPatientMedicalClaimResponseType> {
        let url_ = this.baseUrl + "/mcp/inpatientmedicalclaim/mo/pathology/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpInPatientMedicalClaimMoPathology(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpInPatientMedicalClaimMoPathology(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InPatientMedicalClaimResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InPatientMedicalClaimResponseType>;
        }));
    }

    protected processMcpInPatientMedicalClaimMoPathology(response: HttpResponseBase): Observable<InPatientMedicalClaimResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InPatientMedicalClaimResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpInPatientMedicalClaimMoSpecialist(body: InPatientMedicalClaimRequestType, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<InPatientMedicalClaimResponseType> {
        let url_ = this.baseUrl + "/mcp/inpatientmedicalclaim/mo/specialist/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpInPatientMedicalClaimMoSpecialist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpInPatientMedicalClaimMoSpecialist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InPatientMedicalClaimResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InPatientMedicalClaimResponseType>;
        }));
    }

    protected processMcpInPatientMedicalClaimMoSpecialist(response: HttpResponseBase): Observable<InPatientMedicalClaimResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InPatientMedicalClaimResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpInPatientMedicalClaimPcGeneral(body: InPatientMedicalClaimRequestType, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<InPatientMedicalClaimResponseType> {
        let url_ = this.baseUrl + "/mcp/inpatientmedicalclaim/pc/general/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpInPatientMedicalClaimPcGeneral(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpInPatientMedicalClaimPcGeneral(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InPatientMedicalClaimResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InPatientMedicalClaimResponseType>;
        }));
    }

    protected processMcpInPatientMedicalClaimPcGeneral(response: HttpResponseBase): Observable<InPatientMedicalClaimResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InPatientMedicalClaimResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpInPatientMedicalClaimPcPathology(body: InPatientMedicalClaimRequestType, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<InPatientMedicalClaimResponseType> {
        let url_ = this.baseUrl + "/mcp/inpatientmedicalclaim/pc/pathology/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpInPatientMedicalClaimPcPathology(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpInPatientMedicalClaimPcPathology(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InPatientMedicalClaimResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InPatientMedicalClaimResponseType>;
        }));
    }

    protected processMcpInPatientMedicalClaimPcPathology(response: HttpResponseBase): Observable<InPatientMedicalClaimResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InPatientMedicalClaimResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpInPatientMedicalClaimPcSpecialist(body: InPatientMedicalClaimRequestType, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<InPatientMedicalClaimResponseType> {
        let url_ = this.baseUrl + "/mcp/inpatientmedicalclaim/pc/specialist/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpInPatientMedicalClaimPcSpecialist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpInPatientMedicalClaimPcSpecialist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InPatientMedicalClaimResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InPatientMedicalClaimResponseType>;
        }));
    }

    protected processMcpInPatientMedicalClaimPcSpecialist(response: HttpResponseBase): Observable<InPatientMedicalClaimResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InPatientMedicalClaimResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpInPatientMedicalClaimScGeneral(body: InPatientMedicalClaimRequestType, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<InPatientMedicalClaimResponseType> {
        let url_ = this.baseUrl + "/mcp/inpatientmedicalclaim/sc/general/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpInPatientMedicalClaimScGeneral(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpInPatientMedicalClaimScGeneral(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InPatientMedicalClaimResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InPatientMedicalClaimResponseType>;
        }));
    }

    protected processMcpInPatientMedicalClaimScGeneral(response: HttpResponseBase): Observable<InPatientMedicalClaimResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InPatientMedicalClaimResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpInPatientMedicalClaimScPathology(body: InPatientMedicalClaimRequestType, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<InPatientMedicalClaimResponseType> {
        let url_ = this.baseUrl + "/mcp/inpatientmedicalclaim/sc/pathology/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpInPatientMedicalClaimScPathology(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpInPatientMedicalClaimScPathology(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InPatientMedicalClaimResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InPatientMedicalClaimResponseType>;
        }));
    }

    protected processMcpInPatientMedicalClaimScPathology(response: HttpResponseBase): Observable<InPatientMedicalClaimResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InPatientMedicalClaimResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpInPatientMedicalClaimScSpecialist(body: InPatientMedicalClaimRequestType, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<InPatientMedicalClaimResponseType> {
        let url_ = this.baseUrl + "/mcp/inpatientmedicalclaim/sc/specialist/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpInPatientMedicalClaimScSpecialist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpInPatientMedicalClaimScSpecialist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InPatientMedicalClaimResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InPatientMedicalClaimResponseType>;
        }));
    }

    protected processMcpInPatientMedicalClaimScSpecialist(response: HttpResponseBase): Observable<InPatientMedicalClaimResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InPatientMedicalClaimResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpEligibilityCheck(body: OnlineEligibilityCheckRequestType, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<OnlineEligibilityCheckResponseType> {
        let url_ = this.baseUrl + "/mcp/onlineeligibilitycheck/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpEligibilityCheck(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpEligibilityCheck(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OnlineEligibilityCheckResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OnlineEligibilityCheckResponseType>;
        }));
    }

    protected processMcpEligibilityCheck(response: HttpResponseBase): Observable<OnlineEligibilityCheckResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OnlineEligibilityCheckResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpEligibilityCheckMedicare(body: OnlineEligibilityCheckRequestType, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<OnlineEligibilityCheckResponseType> {
        let url_ = this.baseUrl + "/mcp/onlineeligibilitycheck/medicare/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpEligibilityCheckMedicare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpEligibilityCheckMedicare(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OnlineEligibilityCheckResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OnlineEligibilityCheckResponseType>;
        }));
    }

    protected processMcpEligibilityCheckMedicare(response: HttpResponseBase): Observable<OnlineEligibilityCheckResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OnlineEligibilityCheckResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpEligibilityCheckHf(body: OnlineEligibilityCheckRequestType, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<OnlineEligibilityCheckResponseType> {
        let url_ = this.baseUrl + "/mcp/onlineeligibilitycheck/hf/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpEligibilityCheckHf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpEligibilityCheckHf(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OnlineEligibilityCheckResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OnlineEligibilityCheckResponseType>;
        }));
    }

    protected processMcpEligibilityCheckHf(response: HttpResponseBase): Observable<OnlineEligibilityCheckResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OnlineEligibilityCheckResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpRetrieveReportEra(body: RetrieveReportRequestType, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<RetrieveReportResponseType> {
        let url_ = this.baseUrl + "/mcp/eclipseremittanceadvice/retrievereport/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpRetrieveReportEra(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpRetrieveReportEra(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetrieveReportResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetrieveReportResponseType>;
        }));
    }

    protected processMcpRetrieveReportEra(response: HttpResponseBase): Observable<RetrieveReportResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RetrieveReportResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpRetrieveReportImc(body: RetrieveReportRequestType, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<RetrieveReportResponseType> {
        let url_ = this.baseUrl + "/mcp/inpatientmedicalclaim/retrievereport/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpRetrieveReportImc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpRetrieveReportImc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetrieveReportResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetrieveReportResponseType>;
        }));
    }

    protected processMcpRetrieveReportImc(response: HttpResponseBase): Observable<RetrieveReportResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RetrieveReportResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This is the request
     * @param authorization JWT header for authorization
     * @param dhs_auditId DHS Audit ID
     * @param dhs_subjectId DHS Subject ID
     * @param dhs_messageId DHS Message ID
     * @param dhs_auditIdType DHS Audit Type
     * @param dhs_correlationId DHS Correlation ID
     * @param dhs_productId DHS Product ID
     * @param dhs_subjectIdType DHS Subject ID Type
     * @return successful operation
     */
    mcpStatusReport(body: StatusReportRequestType, authorization: string, dhs_auditId: string, dhs_subjectId: string, dhs_messageId: string, dhs_auditIdType: string, dhs_correlationId: string, dhs_productId: string, dhs_subjectIdType: string): Observable<StatusReportResponseType> {
        let url_ = this.baseUrl + "/mcp/statusreport/v1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "dhs-auditId": dhs_auditId !== undefined && dhs_auditId !== null ? "" + dhs_auditId : "",
                "dhs-subjectId": dhs_subjectId !== undefined && dhs_subjectId !== null ? "" + dhs_subjectId : "",
                "dhs-messageId": dhs_messageId !== undefined && dhs_messageId !== null ? "" + dhs_messageId : "",
                "dhs-auditIdType": dhs_auditIdType !== undefined && dhs_auditIdType !== null ? "" + dhs_auditIdType : "",
                "dhs-correlationId": dhs_correlationId !== undefined && dhs_correlationId !== null ? "" + dhs_correlationId : "",
                "dhs-productId": dhs_productId !== undefined && dhs_productId !== null ? "" + dhs_productId : "",
                "dhs-subjectIdType": dhs_subjectIdType !== undefined && dhs_subjectIdType !== null ? "" + dhs_subjectIdType : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMcpStatusReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMcpStatusReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusReportResponseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusReportResponseType>;
        }));
    }

    protected processMcpStatusReport(response: HttpResponseBase): Observable<StatusReportResponseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusReportResponseType;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceMessagesType;
            return throwException("server cannot or will not process the request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface GetParticipantsRequestType {
    participantType: string;
}

export interface GetParticipantsResponseType {
    participant: CapabilityType[];
}

export interface CapabilityType {
    name: string;
    id: string;
    service: string[];
}

export interface ServiceMessagesType {
    highestSeverity: ServiceMessagesTypeHighestSeverity;
    serviceMessage: ServiceMessageType[];
}

export interface ServiceMessageType {
    code: string;
    severity: ServiceMessageTypeSeverity;
    reason: string;
}

export interface InPatientMedicalClaimRequestType {
    claim: InPatientMedicalClaimType;
    medicareAssessment?: MedicareClaimAssessmentType | undefined;
}

export interface InPatientMedicalClaimType {
    patient: FundPatientType;
    claimant?: ClaimantType | undefined;
    senderContact?: ContactType | undefined;
    medicalEvent: EclipseMedicalEventType[];
    principalProvider?: ProviderType | undefined;
    billingAgent?: ProviderType | undefined;
    accident?: AccidentType | undefined;
    accountPaidInd?: string | undefined;
    accountReferenceId?: string | undefined;
    benefitAssignmentAuthorisedInd?: string | undefined;
    claimTypeCode?: string | undefined;
    compensationClaimInd?: string | undefined;
    facilityId?: string | undefined;
    fundPayeeId?: string | undefined;
    serviceTypeCode?: string | undefined;
    submissionAuthorityInd?: string | undefined;
}

export interface PatientType {
    identity: IdentityType;
    residentialAddress?: AddressType | undefined;
}

export interface FundPatientType extends PatientType {
    alsoKnownAs?: IdentityType | undefined;
    medicare?: MembershipType | undefined;
    healthFund?: FundMembershipType | undefined;
}

export interface IdentityType {
    dateOfBirth?: Date | undefined;
    familyName?: string | undefined;
    givenName?: string | undefined;
    secondInitial?: string | undefined;
    sex?: string | undefined;
}

export interface AddressType {
    addressLineOne?: string | undefined;
    addressLineTwo?: string | undefined;
    locality?: string | undefined;
    postcode?: string | undefined;
}

export interface MembershipType {
    memberNumber?: string | undefined;
    memberRefNumber?: string | undefined;
}

export interface FundMembershipType {
    memberNumber?: string | undefined;
    memberRefNumber?: string | undefined;
    organisation?: string | undefined;
}

export interface MedicarePatientType {
    identity: IdentityType;
    medicare: MembershipType;
}

export interface ClaimantType extends MedicarePatientType {
    eftDetails?: BankAccountType | undefined;
    residentialAddress?: AddressType | undefined;
    contactDetails?: ContactType | undefined;
}

export interface BankAccountType {
    accountName?: string | undefined;
    accountNumber?: string | undefined;
    bsbCode?: string | undefined;
}

export interface ContactType {
    emailAddress?: string | undefined;
    name?: string | undefined;
    phoneNumber?: string | undefined;
}

export interface BaseEclipseMedicalEventType {
    serviceProvider?: ProviderType | undefined;
    referral?: ReferralType | undefined;
    id: string;
    admissionDate?: Date | undefined;
    dischargeDate?: Date | undefined;
    financialInterestDisclosureInd?: string | undefined;
    ifcIssueCode?: string | undefined;
    referralOverrideCode?: string | undefined;
}

export interface EclipseMedicalEventType extends BaseEclipseMedicalEventType {
    service: EclipseServiceType[];
}

export interface ProviderType {
    providerNumber: string;
}

export interface ReferralType {
    issueDate: Date;
    period?: string | undefined;
    periodCode?: string | undefined;
    provider: ProviderType;
    typeCode: string;
}

export interface ServiceType {
    id: string;
    accessionDateTime?: Date | undefined;
    aftercareOverrideInd?: string | undefined;
    chargeAmount?: string | undefined;
    collectionDateTime?: Date | undefined;
    duplicateServiceOverrideInd?: string | undefined;
    fieldQuantity?: string | undefined;
    itemNumber?: string | undefined;
    lspNumber?: string | undefined;
    multipleProcedureOverrideInd?: string | undefined;
    numberOfPatientsSeen?: string | undefined;
    restrictiveOverrideCode?: string | undefined;
    rule3ExemptInd?: string | undefined;
    s4b3ExemptInd?: string | undefined;
    scpId?: string | undefined;
    selfDeemedCode?: string | undefined;
    text?: string | undefined;
    timeDuration?: string | undefined;
}

export interface EclipseServiceType extends ServiceType {
    dateOfService: Date;
    servicePaidInd?: string | undefined;
    timeOfService?: string | undefined;
}

export interface AccidentType {
    accidentDate?: Date | undefined;
    accidentInd?: string | undefined;
}

export interface MedicareClaimAssessmentType {
    currentPatient: MembershipStatusType;
    medicalEvent: MedicareMedicalEventAssessmentType[];
    claimId: string;
    fundLocationId: string;
    lodgementDate: Date;
}

export interface MembershipStatusType {
    status?: StatusType | undefined;
    currentMembership?: MembershipType | undefined;
    currentMember?: IdentityType | undefined;
    processDate?: Date | undefined;
}

export interface StatusType {
    code?: number | undefined;
    text?: string | undefined;
}

export interface MedicareMedicalEventAssessmentType {
    service: MedicareServiceAssessmentType[];
    id: string;
    cardFlagCode?: string | undefined;
}

export interface MedicareServiceAssessmentType {
    id: string;
    benefit: string;
    chargeAmount: string;
    dateOfService: Date;
    explanationCode: string;
    itemNumber: string;
    scheduleFee: string;
}

export interface InPatientMedicalClaimResponseType {
    status?: string | undefined;
    claimSummary?: EclipseClaimSummaryType | undefined;
    medicareStatus?: MembershipStatusType | undefined;
    healthFundStatus?: FundMembershipStatusType | undefined;
    healthFundAssessment?: FundClaimAssessmentType | undefined;
    medicareAssessment?: MedicareClaimAssessmentType | undefined;
}

export interface EclipseClaimSummaryType {
    accountReferenceId?: string | undefined;
}

export interface FundMembershipStatusType {
    status?: StatusType | undefined;
    currentMembership?: FundMembershipType | undefined;
    currentMember?: IdentityType | undefined;
    processDate?: Date | undefined;
}

export interface FundClaimAssessmentType {
    medicalEvent?: FundMedicalEventAssessmentType[] | undefined;
    explanation?: ExplanationType[] | undefined;
    assessmentCode: string;
    authorityToPayInd?: string | undefined;
    personIdentifier?: string | undefined;
}

export interface FundMedicalEventAssessmentType {
    id?: string | undefined;
    service?: FundServiceAssessmentType[] | undefined;
}

export interface FundServiceAssessmentType {
    explanation?: ExplanationType[] | undefined;
    assessmentCode?: string | undefined;
    benefit?: string | undefined;
    chargeAmount?: string | undefined;
    dateOfService?: Date | undefined;
    id?: string | undefined;
    itemNumber?: string | undefined;
    medicalPaymentType?: string | undefined;
    scheduleFee?: string | undefined;
}

export interface ExplanationType {
    code?: string | undefined;
    text?: string | undefined;
}

export interface OnlineEligibilityCheckRequestType {
    claim: OnlineEligibilityCheckClaimType;
    medicareEstimation?: MedicareClaimEstimationType | undefined;
}

export interface OnlineEligibilityCheckClaimType {
    patient: FundPatientType;
    senderContact?: ContactType | undefined;
    principalProvider?: ProviderType | undefined;
    accident?: AccidentType | undefined;
    typeCode: string;
    accountReferenceId: string;
    claimTypeCode?: string | undefined;
    compensationClaimInd?: string | undefined;
    emergencyAdmissionInd?: string | undefined;
    facilityId?: string | undefined;
    fundPayeeId?: string | undefined;
    hospitalInd?: string | undefined;
    lengthOfStay?: number | undefined;
    peaRequestInd?: string | undefined;
    presentingIllnessCode?: string | undefined;
    presentingIllnessItemNumber?: string | undefined;
    sameDayInd?: string | undefined;
    serviceTypeCode?: string | undefined;
    submissionAuthorityInd: string;
    medicalEvent: OnlineEligibilityCheckMedicalEventType[];
}

export interface OnlineEligibilityCheckMedicalEventType extends BaseEclipseMedicalEventType {
    service?: OnlineEligibilityCheckServiceType[] | undefined;
}

export interface OnlineEligibilityCheckServiceType extends ServiceType {
    serviceCode?: string | undefined;
    serviceCodeTypeCode?: string | undefined;
    serviceQuantity?: number | undefined;
    serviceRate?: number | undefined;
    timeDependantOverrideInd?: string | undefined;
    restrictionOverrideInd?: string | undefined;
    dateOfService?: Date | undefined;
}

export interface MedicareClaimEstimationType {
    medicalEvent?: MedicareMedicalEventEstimationType[] | undefined;
    lodgementDate?: Date | undefined;
    fundLocationId?: string | undefined;
}

export interface MedicareMedicalEventEstimationType {
    id?: string | undefined;
    service?: MedicareServiceEstimationType[] | undefined;
}

export interface MedicareServiceEstimationType {
    chargeAmount?: string | undefined;
    dateOfService?: Date | undefined;
    itemNumber?: string | undefined;
    benefit?: number | undefined;
    explanationCode?: string | undefined;
    scheduleFee?: number | undefined;
    id?: string | undefined;
}

export interface OnlineEligibilityCheckResponseType {
    status: string;
    claimSummary?: EclipseClaimSummaryType | undefined;
    medicareStatus?: MembershipStatusType | undefined;
    healthFundStatus?: FundMembershipStatusType | undefined;
    healthFundClaimEstimation?: HealthFundClaimEstimationType | undefined;
    medicareClaimEstimation?: MedicareClaimEstimationType | undefined;
}

export interface HealthFundClaimEstimationType {
    medicalEvent?: HealthFundMedicalEventEstimationType[] | undefined;
    patientCoPayment?: CoPaymentType | undefined;
    patientExcessPayment?: ExcessPaymentType | undefined;
    explanation?: ExplanationType[] | undefined;
    healthFundTable?: HealthFundTableType | undefined;
    benefitLimitations?: string | undefined;
    exclusionDescription?: string | undefined;
    fundReferenceId?: string | undefined;
    fundAssessmentCode?: string | undefined;
    peaPotentialInd?: string | undefined;
    financialStatus?: string | undefined;
}

export interface HealthFundMedicalEventEstimationType {
    id?: string | undefined;
    service?: HealthFundServiceEstimationType[] | undefined;
}

export interface HealthFundServiceEstimationType {
    explanation?: ExplanationType[] | undefined;
    chargeAmount?: string | undefined;
    dateOfService?: Date | undefined;
    benefit?: number | undefined;
    itemNumber?: string | undefined;
    serviceCode?: string | undefined;
    serviceCodeTypeCode?: string | undefined;
    fundAssessmentCode?: string | undefined;
    id?: string | undefined;
}

export interface PatientPaymentType {
    amount?: number | undefined;
    amountDescription?: string | undefined;
}

export interface CoPaymentType extends PatientPaymentType {
    daysRemaining?: number | undefined;
}

export interface ExcessPaymentType extends PatientPaymentType {
    bonusAmount?: number | undefined;
}

export interface HealthFundTableType {
    tableDescription?: string | undefined;
    tableName?: string | undefined;
    tableScale?: string | undefined;
}

export interface RetrieveReportRequestType {
    transactionId: string[];
}

export interface RetrieveReportResponseType {
    content?: ContentType[] | undefined;
}

export interface ContentType {
    transactionId?: string | undefined;
    status?: string | undefined;
}

export interface EclipseRemittanceAdviceReportContentType extends ContentType {
    report?: EclipseRemittanceAdviceReportType | undefined;
}

export interface EclipseRemittanceAdviceReportType {
    partNumber: number;
    partTotal: number;
    payeeLocationId: string;
    remittanceAdviceId?: string | undefined;
    paymentInfo: PaymentType;
    paymentRun: PaymentRunType;
    claimSummary: RemittanceAdviceClaimSummaryType[];
}

export interface PaymentType {
    accountInfo: BankAccountType;
    depositAmount?: string | undefined;
    paymentReference?: string | undefined;
}

export interface PaymentRunType {
    payerName?: string | undefined;
    runDate?: Date | undefined;
    runNumber?: string | undefined;
}

export interface RemittanceAdviceClaimSummaryType extends EclipseClaimSummaryType {
    benefit: string;
    channelCode?: string | undefined;
    claimId?: string | undefined;
    lodgementDate: Date;
    transactionId?: string | undefined;
    previousTransactionId?: string | undefined;
    previousAccountReferenceId?: string | undefined;
}

export interface InPatientMedicalClaimReportContentType extends ContentType {
    report?: InPatientMedicalClaimResponseType | undefined;
}

export interface StatusReportRequestType {
    transactionId?: string[] | undefined;
    associateName?: string | undefined;
    fromDateTime?: Date | undefined;
    toDateTime?: Date | undefined;
    reportStatus?: string | undefined;
    requestTransmissionType?: string | undefined;
    status?: string | undefined;
}

export interface StatusReportResponseType {
    transactionStatus?: TransactionStatusType[] | undefined;
    status: string;
}

export interface TransactionStatusType {
    associateName?: string | undefined;
    lodgementDateTime?: Date | undefined;
    processStatus?: string | undefined;
    reference?: string | undefined;
    reportStatus?: string | undefined;
    requestTransmissionType?: string | undefined;
    transactionId?: string | undefined;
}

export enum ServiceMessagesTypeHighestSeverity {
    Fatal = "Fatal",
    Error = "Error",
    Warning = "Warning",
    Informational = "Informational",
}

export enum ServiceMessageTypeSeverity {
    Fatal = "Fatal",
    Error = "Error",
    Warning = "Warning",
    Informational = "Informational",
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}

}